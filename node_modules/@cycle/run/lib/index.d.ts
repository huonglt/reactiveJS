import { MemoryStream } from 'xstream';
export interface FantasyObserver {
    next(x: any): void;
    error(err: any): void;
    complete(c?: any): void;
}
export interface FantasySubscription {
    unsubscribe(): void;
}
export interface FantasyObservable {
    subscribe(observer: FantasyObserver): FantasySubscription;
}
export declare type DisposeFunction = () => void;
export interface DevToolEnabledSource {
    _isCycleSource: string;
}
export interface Driver<Sink, Source> {
    (stream: Sink, driverName?: string): Source;
}
export declare type Drivers<So extends Sources, Si extends Sinks> = {
    [P in keyof (So & Si)]: Driver<Si[P], So[P]>;
};
export declare type Sources = {
    [name: string]: any;
};
export declare type Sinks = {
    [name: string]: FantasyObservable;
};
/**
 * Sink proxies should be MemoryStreams in order to fix race conditions for
 * drivers that subscribe to sink proxies "later".
 *
 * Recall that there are two steps:
 * 1. Setup (sink proxies -> drivers -> sources -> main -> sink)
 * 2. Execution (also known as replication: sink proxies imitate sinks)
 *
 * If a driver does not synchronously/immediately subscribe to the sink proxy
 * in step (1), but instead does that later, if step (2) feeds a value from the
 * sink to the sink proxy, then when the driver subscribes to the sink proxy,
 * it should receive that value. This is why we need MemoryStreams, not just
 * Streams. Note: Cycle DOM driver is an example of such case, since it waits
 * for 'readystatechange'.
 */
export declare type SinkProxies<Si extends Sinks> = {
    [P in keyof Si]: MemoryStream<any>;
};
export interface CycleProgram<So extends Sources, Si extends Sinks> {
    sources: So;
    sinks: Si;
    run(): DisposeFunction;
}
/**
 * A function that prepares the Cycle application to be executed. Takes a `main`
 * function and prepares to circularly connects it to the given collection of
 * driver functions. As an output, `setup()` returns an object with three
 * properties: `sources`, `sinks` and `run`. Only when `run()` is called will
 * the application actually execute. Refer to the documentation of `run()` for
 * more details.
 *
 * **Example:**
 * ```js
 * import {setup} from '@cycle/run';
 * const {sources, sinks, run} = setup(main, drivers);
 * // ...
 * const dispose = run(); // Executes the application
 * // ...
 * dispose();
 * ```
 *
 * @param {Function} main a function that takes `sources` as input and outputs
 * `sinks`.
 * @param {Object} drivers an object where keys are driver names and values
 * are driver functions.
 * @return {Object} an object with three properties: `sources`, `sinks` and
 * `run`. `sources` is the collection of driver sources, `sinks` is the
 * collection of driver sinks, these can be used for debugging or testing. `run`
 * is the function that once called will execute the application.
 * @function setup
 */
export declare function setup<So extends Sources, Si extends Sinks>(main: (sources: So) => Si, drivers: Drivers<So, Si>): CycleProgram<So, Si>;
/**
 * Takes a `main` function and circularly connects it to the given collection
 * of driver functions.
 *
 * **Example:**
 * ```js
 * import run from '@cycle/run';
 * const dispose = run(main, drivers);
 * // ...
 * dispose();
 * ```
 *
 * The `main` function expects a collection of "source" streams (returned from
 * drivers) as input, and should return a collection of "sink" streams (to be
 * given to drivers). A "collection of streams" is a JavaScript object where
 * keys match the driver names registered by the `drivers` object, and values
 * are the streams. Refer to the documentation of each driver to see more
 * details on what types of sources it outputs and sinks it receives.
 *
 * @param {Function} main a function that takes `sources` as input and outputs
 * `sinks`.
 * @param {Object} drivers an object where keys are driver names and values
 * are driver functions.
 * @return {Function} a dispose function, used to terminate the execution of the
 * Cycle.js program, cleaning up resources used.
 * @function run
 */
export declare function run<So extends Sources, Si extends Sinks>(main: (sources: So) => Si, drivers: Drivers<So, Si>): DisposeFunction;
export default run;
